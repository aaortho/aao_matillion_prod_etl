type: "orchestration"
version: "1.0"
pipeline:
  components:
    Start:
      type: "start"
      transitions:
        unconditional:
        - "get last run date time"
      parameters:
        componentName: "Start"
    get last run date time:
      type: "query-to-scalar"
      transitions:
        success:
        - "Products incremental"
      parameters:
        componentName: "get last run date time"
        mode: "Advanced"
        query: "SELECT \r\n    TABLE_NAME, \r\n    TO_CHAR(MAX(LOAD_TIME), 'YYYY-MM-DD\"\
          T\"HH24:MI:SS\"Z\"') AS LAST_LOAD_TIME\r\nFROM \r\n    PROD_BRONZE_DB.LMS.LMS_AUDIT_LOG\r\
          \nWHERE \r\n    TABLE_NAME = 'PRODUCTS'\r\n    AND LOAD_STATUS = 'SUCCESS'\r\
          \nGROUP BY \r\n    TABLE_NAME\r\nORDER BY \r\n    LAST_LOAD_TIME DESC"
        scalarVariableMapping:
        - - "v_modified_date"
          - "LAST_LOAD_TIME"
      postProcessing:
        updateOutputMessage:
        updateScalarVariables:
    Products incremental:
      type: "modular-api-extract-input-v2"
      transitions:
        success:
        - "Log Products Ingestion"
        failure:
        - "Log Products API Failure"
      parameters:
        componentName: "Products incremental"
        componentId: "custom_v2-01ba2d07-e6ae-413d-a524-b9f50f046c72"
        inputId: "api-extract-input-v2"
        api-extract-input-v2:
          profile: "custom-01ba2d07-e6ae-413d-a524-b9f50f046c72"
          endpoint: "Products incremental"
          connectionRef:
            overrides:
              authType: "NONE"
          uriParams:
          queryParams:
          - name: "modified_after"
            value: "${v_modified_date}"
          headerParams:
          postBody:
          pageLimit:
          logLevel: "ERROR"
          loadSelectedData: "No"
        outputId: "snowflake-output-connector-v0"
        snowflake-output-connector-v0:
          warehouse: "[Environment Default]"
          database: "[Environment Default]"
          schema: "LMS"
          tableName: "PRODUCTS"
          createTableMode: "TRUNCATE_AND_INSERT"
          cleanStagedFiles: "Yes"
          stagePlatform: "SNOWFLAKE"
          snowflake#internalStageType: "USER"
      postProcessing:
        updateOutputMessage:
        updateScalarVariables:
    Log Products API Failure:
      type: "sql-executor"
      parameters:
        componentName: "Log Products API Failure"
        scriptLocation: "Component"
        declareSqlVariables: "Include selected"
        variablesToInclude:
        sqlScript: |
          -- Log failure to audit table with error details
          INSERT INTO PROD_BRONZE_DB.LMS.LMS_AUDIT_LOG (
              TABLE_NAME,
              ROW_COUNT,
              LOAD_TIME,
              LOAD_STATUS,
              ERROR_MESSAGE
          )
          VALUES (
              'PRODUCTS',
              -1,  -- Negative count indicates failure
              CURRENT_TIMESTAMP,
              'FAILED',  -- Load status indicating failure
              'Failed: Unknown error occurred during LMS Products API processing'
          );
      postProcessing:
        updateOutputMessage:
        updateScalarVariables:
    Log Products Ingestion:
      type: "sql-executor"
      transitions:
        success:
        - "Data Parser Products"
      parameters:
        componentName: "Log Products Ingestion"
        scriptLocation: "Component"
        declareSqlVariables: "Include all"
        sqlScript: "-- Log success to audit table\nINSERT INTO PROD_BRONZE_DB.LMS.LMS_AUDIT_LOG\
          \ (\n    TABLE_NAME,\n    ROW_COUNT,\n    LOAD_TIME,\n    LOAD_STATUS,\n\
          \    ERROR_MESSAGE\n)\nSELECT \n    'PRODUCTS' AS TABLE_NAME,\n    COUNT(*)\
          \ AS ROW_COUNT,\n    CURRENT_TIMESTAMP AS LOAD_TIME,\n    'SUCCESS' AS LOAD_STATUS,\n\
          \    NULL AS ERROR_MESSAGE\nFROM PROD_BRONZE_DB.LMS.PRODUCTS;\n"
    Data Parser Products:
      type: "sql-executor"
      transitions:
        success:
        - "Merge PRODUCT_CTS"
      parameters:
        componentName: "Data Parser Products"
        scriptLocation: "Component"
        declareSqlVariables: "Include selected"
        variablesToInclude:
        sqlScript: "MERGE INTO PROD_SILVER_DB.LMS.PRODUCTS AS target\r\nUSING (\r\n\
          \    SELECT\r\n        item.value:id::STRING AS id,\r\n        item.value:api_key::STRING\
          \ AS api_key,\r\n        item.value:created_at::TIMESTAMP AS created_at,\r\
          \n        item.value:description::STRING AS description,\r\n        item.value:discoverable::BOOLEAN\
          \ AS discoverable,\r\n        item.value:icon_url::STRING AS icon_url,\r\
          \n        item.value:identification::STRING AS identification,\r\n     \
          \   item.value:name::STRING AS name,\r\n        item.value:status::STRING\
          \ AS status,\r\n        item.value:teaser::STRING AS teaser,\r\n       \
          \ item.value:type::STRING AS type\r\n    FROM PROD_BRONZE_DB.LMS.PRODUCTS,\r\
          \n         LATERAL FLATTEN(input => DATA_VALUE:data) AS item\r\n) AS source\r\
          \nON target.id = source.id\r\n\r\nWHEN MATCHED THEN\r\n    UPDATE SET\r\n\
          \        target.api_key = source.api_key,\r\n        target.created_at =\
          \ source.created_at,\r\n        target.description = source.description,\r\
          \n        target.discoverable = source.discoverable,\r\n        target.icon_url\
          \ = source.icon_url,\r\n        target.identification = source.identification,\r\
          \n        target.name = source.name,\r\n        target.status = source.status,\r\
          \n        target.teaser = source.teaser,\r\n        target.type = source.type\r\
          \n\r\nWHEN NOT MATCHED THEN\r\n    INSERT (\r\n        id,\r\n        api_key,\r\
          \n        created_at,\r\n        description,\r\n        discoverable,\r\
          \n        icon_url,\r\n        identification,\r\n        name,\r\n    \
          \    status,\r\n        teaser,\r\n        type\r\n    )\r\n    VALUES (\r\
          \n        source.id,\r\n        source.api_key,\r\n        source.created_at,\r\
          \n        source.description,\r\n        source.discoverable,\r\n      \
          \  source.icon_url,\r\n        source.identification,\r\n        source.name,\r\
          \n        source.status,\r\n        source.teaser,\r\n        source.type\r\
          \n    );\r\n"
      postProcessing:
        updateOutputMessage:
        updateScalarVariables:
    Run pl_lms_product_details_incremental_load:
      type: "run-orchestration"
      parameters:
        componentName: "Run pl_lms_product_details_incremental_load"
        orchestrationJob: "lms_data_ingestion/LMS Incremental Data Ingestion/pl_lms_product_details_incremental_load.orch.yaml"
        setScalarVariables:
        setGridVariables:
      postProcessing:
        updateOutputMessage:
        updateScalarVariables:
    'Merge PRODUCT_CTS_TAGS ':
      type: "sql-executor"
      transitions:
        success:
        - "Run pl_lms_product_details_incremental_load"
      parameters:
        componentName: "Merge PRODUCT_CTS_TAGS "
        scriptLocation: "Component"
        declareSqlVariables: "Include selected"
        variablesToInclude:
        sqlScript: "MERGE INTO PROD_SILVER_DB.LMS.PRODUCT_CTS_TAGS AS target\r\nUSING\
          \ (\r\n  SELECT\r\n    item.value:id::STRING AS product_id,\r\n    cts.value:id::STRING\
          \ AS cts_id,\r\n    tag.value:id::STRING AS tag_id,\r\n    tag.value:label::STRING\
          \ AS tag_label\r\n  FROM PROD_BRONZE_DB.LMS.PRODUCTS,\r\n    LATERAL FLATTEN(input\
          \ => DATA_VALUE:data) AS item,\r\n    LATERAL FLATTEN(input => item.value:cts)\
          \ AS cts,\r\n    LATERAL FLATTEN(input => cts.value:tags) AS tag\r\n) AS\
          \ source\r\nON target.product_id = source.product_id\r\n   AND target.cts_id\
          \ = source.cts_id\r\n   AND target.tag_id = source.tag_id\r\nWHEN MATCHED\
          \ THEN\r\n  UPDATE SET target.tag_label = source.tag_label\r\nWHEN NOT MATCHED\
          \ THEN\r\n  INSERT (product_id, cts_id, tag_id, tag_label)\r\n  VALUES (source.product_id,\
          \ source.cts_id, source.tag_id, source.tag_label);"
      postProcessing:
        updateOutputMessage:
        updateScalarVariables:
    Merge PRODUCT_CTS:
      type: "sql-executor"
      transitions:
        success:
        - "Merge PRODUCT_CTS_TAGS "
      parameters:
        componentName: "Merge PRODUCT_CTS"
        scriptLocation: "Component"
        declareSqlVariables: "Include selected"
        variablesToInclude:
        sqlScript: "MERGE INTO PROD_SILVER_DB.LMS.PRODUCT_CTS AS target\r\nUSING (\r\
          \n  SELECT\r\n    item.value:id::STRING AS product_id,\r\n    cts.value:id::STRING\
          \ AS cts_id,\r\n    cts.value:label::STRING AS cts_label\r\n  FROM PROD_BRONZE_DB.LMS.PRODUCTS,\r\
          \n    LATERAL FLATTEN(input => DATA_VALUE:data) AS item,\r\n    LATERAL\
          \ FLATTEN(input => item.value:cts) AS cts\r\n) AS source\r\nON target.product_id\
          \ = source.product_id\r\n   AND target.cts_id = source.cts_id\r\nWHEN MATCHED\
          \ THEN\r\n  UPDATE SET target.cts_label = source.cts_label\r\nWHEN NOT MATCHED\
          \ THEN\r\n  INSERT (product_id, cts_id, cts_label)\r\n  VALUES (source.product_id,\
          \ source.cts_id, source.cts_label);"
      postProcessing:
        updateOutputMessage:
        updateScalarVariables:
  variables:
    v_modified_date:
      metadata:
        type: "TEXT"
        description: ""
        scope: "COPIED"
        visibility: "PUBLIC"
      defaultValue: "2019-01-01T00:00:00Z"
design:
  components:
    Start:
      position:
        x: -220
        "y": -30
      tempMetlId: 1
    get last run date time:
      position:
        x: -110
        "y": -30
      tempMetlId: 3
    Products incremental:
      position:
        x: 40
        "y": -30
      tempMetlId: 4
    Log Products API Failure:
      position:
        x: 200
        "y": -130
      tempMetlId: 5
    Log Products Ingestion:
      position:
        x: 200
        "y": -30
      tempMetlId: 6
    Data Parser Products:
      position:
        x: 330
        "y": -30
      tempMetlId: 7
    Run pl_lms_product_details_incremental_load:
      position:
        x: 780
        "y": -30
      tempMetlId: 9
    'Merge PRODUCT_CTS_TAGS ':
      position:
        x: 630
        "y": -30
      tempMetlId: 10
    Merge PRODUCT_CTS:
      position:
        x: 480
        "y": -30
      tempMetlId: 11
